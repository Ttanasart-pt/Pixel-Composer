//
// Simple passthrough vertex shader
//
attribute vec3 in_Position;                  // (x,y,z)
//attribute vec3 in_Normal;                  // (x,y,z)     unused in this shader.
attribute vec4 in_Colour;                    // (r,g,b,a)
attribute vec2 in_TextureCoord;              // (u,v)

varying vec2 v_vTexcoord;
varying vec4 v_vColour;

void main()
{
    vec4 object_space_pos = vec4( in_Position.x, in_Position.y, in_Position.z, 1.0);
    gl_Position = gm_Matrices[MATRIX_WORLD_VIEW_PROJECTION] * object_space_pos;
    
    v_vColour = in_Colour;
    v_vTexcoord = in_TextureCoord;
}

//######################_==_YOYO_SHADER_MARKER_==_######################@~
varying vec2 v_vTexcoord;
varying vec4 v_vColour;

uniform float colors;
uniform int   alpha;
uniform vec3  cMin, cMax;

uniform vec2      gamma;
uniform int       gammaUseSurf;
uniform sampler2D gammaSurf;


	vec3 rgb2hsv(vec3 c) { 
		vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
	    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
	    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));
	
	    float d = q.x - min(q.w, q.y);
	    float e = 0.0000000001;
	    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
	 } 
	
	vec3 hsv2rgb(vec3 c) { 
	    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
	    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
	    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
	} 
	
	float hue2rgb( in float m1, in float m2, in float hue) { 
		if (hue < 0.0)
			hue += 1.0;
		else if (hue > 1.0)
			hue -= 1.0;
	
		if ((6.0 * hue) < 1.0)
			return m1 + (m2 - m1) * hue * 6.0;
		else if ((2.0 * hue) < 1.0)
			return m2;
		else if ((3.0 * hue) < 2.0)
			return m1 + (m2 - m1) * ((2.0 / 3.0) - hue) * 6.0;
		else
			return m1;
	} 
	
	vec3 hsl2rgb( in vec3 hsl ) { 
		float r, g, b;
		if(hsl.y == 0.) {
			r = hsl.z;
			g = hsl.z;
			b = hsl.z;
		} else {
			float m1, m2;
			if(hsl.z <= 0.5)
				m2 = hsl.z * (1. + hsl.y);
			else 
				m2 = hsl.z + hsl.y - hsl.z * hsl.y;
			m1 = 2. * hsl.z - m2;
			
			r = hue2rgb(m1, m2, hsl.x + 1. / 3.);
			g = hue2rgb(m1, m2, hsl.x);
			b = hue2rgb(m1, m2, hsl.x - 1. / 3.);
		}
		
		return vec3( r, g, b );
	} 
	
	vec3 rgb2hsl( in vec3 c ) { 
		float h = 0.0;
		float s = 0.0;
		float l = 0.0;
		float r = c.r;
		float g = c.g;
		float b = c.b;
		float cMin = min( r, min( g, b ) );
		float cMax = max( r, max( g, b ) );
	
		l = ( cMax + cMin ) / 2.0;
		if ( cMax > cMin ) {
			float cDelta = cMax - cMin;
			
			s = l < .5 ? cDelta / ( cMax + cMin ) : cDelta / ( 2.0 - ( cMax + cMin ) );
			
			if ( r == cMax )
				h = ( g - b ) / cDelta;
			else if ( g == cMax )
				h = 2.0 + ( b - r ) / cDelta;
			else
				h = 4.0 + ( r - g ) / cDelta;
			
			if ( h < 0.0)
				h += 6.0;
			h = h / 6.0;
		}
		return vec3( h, s, l );
	} 


float round(float a) { return fract(a) >= 0.5? ceil(a) : floor(a); }
vec2  round(vec2  a) { return vec2(round(a.x), round(a.y)); }
vec3  round(vec3  a) { return vec3(round(a.x), round(a.y), round(a.z)); }

void main() {
	float gam = gamma.x;
	if(gammaUseSurf == 1) {
		vec4 _vMap = texture2D( gammaSurf, v_vTexcoord );
		gam = mix(gamma.x, gamma.y, (_vMap.r + _vMap.g + _vMap.b) / 3.);
	}
	
	gam = max(gam, .0001);
	
	vec3 cRan = cMax - cMin;
	vec4 _col = texture2D( gm_BaseTexture, v_vTexcoord );
    _col.rgb  = clamp((_col.rgb - cMin) / cRan, 0., 1.);
	
	vec3 c = _col.rgb;
	
	c = pow(c, vec3(gam));
	c = floor(c * colors) / (colors - 1.);
	c = pow(c, vec3(1.0 / gam));
	_col = vec4(cMin + c * cRan, 1.);
	
	_col.a = alpha == 1? 1. : _col.a;
	
	gl_FragColor = _col;
}

